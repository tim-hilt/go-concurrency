package main

import (
	"log"
)

// genNums generates a channel and passes in all natural numbers between
// 0 and 999999.
// The fanOut-pattern will perform action on the data generated by this
// function.
func genNums() chan int {
	c := make(chan int)
	go func() {
		for i := 0; i < 1000000; i++ {
			c <- i
		}
		close(c)
	}()
	return c
}

// double returns the doubled input-value.
// double is the action that will be performed on the distributed
// data.
func double(i int) int {
	return i * 2
}

// fanOut distributes performing `action` on all values from `inputChannel`.
// The work will be distributed onto `numWorkers` workers.
func fanOut(inputChannel chan int, numWorkers int, action func(int) int) (workers []chan int) {
	for i := 0; i < numWorkers; i++ {
		worker := make(chan int)

		go func() {
			for inputValue := range inputChannel {
				// read values from `inputChannel` and perform `action` on it
				worker <- action(inputValue)
			}
			close(worker) // close worker-channel as soon as inputChannel is closed
		}()

		workers = append(workers, worker) // add current worker to workers-array
	}
	return
}

// fanIn consolidates all values from the `workers` into
// a single channel
func fanIn(workers []chan int) chan int {
	outputChannel := make(chan int)

	// `outputChannel` has to be closed as soon as the workers don't yield any values anymore.
	// We'll use a channel to keep track of when that happens.
	workerDone := make(chan string)

	for _, worker := range workers {
		go func(worker chan int) {
			for value := range worker {
				// pass values from current worker into `outputChannel``
				outputChannel <- value
			}
			workerDone <- "done"
		}(worker)
	}

	go func() {
		for i := 0; i < len(workers); i++ {
			<-workerDone
		}
		close(workerDone)    // close waitGroup as soon as all workers signal they're done
		close(outputChannel) // close outputChannel as soon as all workers are finished
	}()

	return outputChannel
}

func main() {
	nums := genNums() // generate data to be acted on

	numWorkers := 12
	action := double
	workers := fanOut(nums, numWorkers, action) // distribute work

	processedNums := fanIn(workers) // collect processed data into single channel

	// do something with processed data
	for num := range processedNums {
		log.Println(num)
	}
}
